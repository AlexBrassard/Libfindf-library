/*
 *
 *
 *  Libfindf.so  -  Regular expression utilities.
 *
 *
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <errno.h>
#include <pthread.h>
#include <regex.h>
#include <findf.h>

#include "libfindf_private.h"

/* Dummy */
void *dummy(void *dumdum){
  printf("inside dummy\n\n");
  return ((void*)1);
}

/* Initialize a findf_regex_f object. 
findf_regex_f* intern__findf__init_regex(char *pattern,
					 bool compw_icase,
					 bool compw_newline)
{
  findf_regex_f *to_init = NULL;
  char error_string[F_MAXNAMELEN];
  int reg_errorcode = 0;

  if ((to_init = malloc(sizeof(findf_regex_f))) == NULL){
    intern_errormesg("Malloc");
    return NULL;
  }
  if ((to_init->pattern = malloc(sizeof(regex_t))) == NULL){
    intern_errormesg("Malloc");
    goto cleanup;
  }

  if ((reg_errorcode = regcomp(to_init->pattern,
			       pattern,
			       (compw_newline == true) ? REG_NEWLINE : 0 |
			       (compw_icase == true) ? REG_ICASE : 0 |
			       REG_EXTENDED |
			       REG_NOSUB)) != 0){
    
    regerror(reg_errorcode, to_init->pattern, error_string, F_MAXNAMELEN);
    intern_errormesg(error_string);
    goto cleanup;
  }

  return to_init;

 cleanup:
  if (to_init){
    if (to_init->pattern){
      regfree(to_init->pattern);
      to_init->pattern = NULL;
    }
    free(to_init);
  }
  return NULL;
}
*/

int intern__findf__free_regex(findf_regex_f* to_free)
{
  /* Set errno if the findf_regex_f pointer is NULL but succeed anyway. */
  if (to_free == NULL){
    errno = ENODATA;
    return RF_OPSUCC;
  }
  regfree(to_free->pattern);
  if (to_free->pattern)
    free(to_free->pattern);
  to_free->pattern = NULL;
  to_free->operation = NULL;
  free(to_free);
  return RF_OPSUCC;

}

int intern__findf__free_regarray(findf_regex_f** to_free,
				 size_t numof_patterns)
{
  size_t i = 0;
  /* Set errno if we're passed a NULL valued pointer but succeed anyway. */
  if (to_free == NULL){
    errno = ENODATA;
    return RF_OPSUCC;
  }
  for (; i < numof_patterns; i++)
    intern__findf__free_regex(to_free[i]);
  free(to_free);

  return RF_OPSUCC;
}


/*
 * Removes the operation, delimiters and modifiers
 * of a given expression and returns the stripped pattern.
 */
char* intern__findf__strip_pattern(char *intern_pattern,
				   findf_regex_f *freg_object)
{
  bool reach_delimiter = false;
  size_t pattern_char = 0;
  size_t stripped_pattern_c = 0;
  char *stripped_pattern = NULL;
  char delimiter;

  if ((stripped_pattern = calloc(FINDF_MAX_PATTERN_LEN, sizeof(char))) == NULL){
    intern_errormesg("Malloc");
    return NULL;
  }

  /* Fetch the operation. */
  switch(intern_pattern[0]){
  case 'm':
    freg_object->fre_op_match = true;
    pattern_char++;
    break;
  case 's':
    freg_object->fre_op_substitute = true;
    pattern_char++;
    break;
  case 't':
    if (intern_pattern[1] == 'r'){
      freg_object->fre_op_transliterate = true;
      pattern_char = 2;
      break;
    }
    else {
      intern_errormesg("Unknown operation in pattern");
      goto cleanup;
    }
  default:
    /* 
     * Check if the current character is a punctuation mark.
     * If yes, we assume a match operation and use this mark as
     * the pattern's delimiter.
     */
    if (ispunct(intern_pattern[pattern_char])){
      freg_object->fre_op_match = true;
      break;
    }
    else { /* Error */
      intern_errormesg("Unknow operation in pattern");
      goto cleanup;
    }
  }

  /* Set the delimiter. */
  delimiter = intern_pattern[pattern_char];
  pattern_char++;

  while(intern_pattern[pattern_char] != '\0'){
    if (reach_delimiter == false){
      if (intern_pattern[pattern_char] == delimiter){
	stripped_pattern[stripped_pattern_c] = '\0';
	pattern_char++;
	reach_delimiter = true;
	
      }
      else{
	stripped_pattern[stripped_pattern_c] = intern_pattern[pattern_char];
	stripped_pattern_c++;
	pattern_char++;
      }
    }
    else {
      switch(intern_pattern[pattern_char]){
      case 'm':
	freg_object->fre_modif_boleol = true;
	break;
      case 's':
	freg_object->fre_modif_newline = true;
	break;
      case 'i':
	freg_object->fre_modif_icase = true;
	break;
      case 'g':
	freg_object->fre_modif_global = true;
	break;
      case 'x':
	freg_object->fre_modif_ext = true;
	break;
      default:
	intern_errormesg("Syntax error, Unknown modifier in pattern");
	goto cleanup;
      }
      pattern_char++;
    }  
	  
  } 

  /* Make sure we found the second delimiter. */
  if (reach_delimiter == true){
    /* Return the stripped off pattern. */
    return stripped_pattern;
  }
  else {
    /* Or an error ! */
    intern_errormesg("Syntax error: Second pattern delimiter not found.");
    goto cleanup;
  }
	
  
 cleanup:
  if (stripped_pattern){
    free(stripped_pattern);
    stripped_pattern = NULL;
  }
  return NULL;
}
      
      
/* 
 * Parse the Perl-like regex pattern.
 * Modify it into a fully conformant POSIX
 * extended regular expression.
 */

findf_regex_f** intern__findf__parse_patterns(char **patterns,
					      size_t numof_patterns)
{
  size_t i = 0;
  size_t patterns_c = 0;                                 /* Current pattern we're working on. */
  size_t pattern_char = 0;                               /* Used to loop through each characters of each patterns. */
  size_t tmp_pattern_c = 0;                              /* Used to build the pattern to compile, a char at a time. */
  size_t tmp_pattern_len = 0;                            /* Lenght of the unmodified pattern, stripped from op/modif flags. */
  size_t intern_pattern_len = 0;                         /* Lenght of intern_pattern. */
  bool   reach_delimiter = false;                        /* True when we reach the 2nd delimiter of an expression. */
  char   *intern_pattern = NULL;                         /* We copy each patterns in this array. */
  char   *tmp_pattern = NULL;                            /* The pattern without op/modif flags, to be compiled. */
  findf_regex_f **reg_array = NULL;                      /* The array of compiled pattern to return to our caller. */

  /* findf_re() verified the numof_patterns already. Allocate memory.*/
  if ((reg_array = malloc(numof_patterns * sizeof(findf_regex_f*))) == NULL){
    intern_errormesg("Malloc");
    return NULL;
  }
  for (i = 0; i < numof_patterns; i++){
    if ((reg_array[i] = malloc(sizeof(findf_regex_f))) == NULL){
      intern_errormesg("Malloc");
      goto cleanup;
    }
  }
  if ((intern_pattern = calloc(FINDF_MAX_PATTERN_LEN, sizeof(char))) == NULL){
    intern_errormesg("Calloc");
    goto cleanup;
  }
  if ((tmp_pattern = calloc(FINDF_MAX_PATTERN_LEN, sizeof(char))) == NULL){
    intern_errormesg("Calloc");
    goto cleanup;
  }

  /* Loop over each of caller's patterns.  */
  for (patterns_c = 0; patterns_c < numof_patterns; patterns_c++){
    if (SU_strcpy(intern_pattern, patterns[patterns_c], FINDF_MAX_PATTERN_LEN) == NULL){
      intern_errormesg("SU_strcpy failure");
      goto cleanup;
    }
    /* Strip the pattern of all its operation, delimiter and modifier characters. */
    if ((intern_pattern = intern__findf__strip_pattern(intern_pattern, reg_array[patterns_c])) == NULL){
      intern_errormesg("Could not strip pattern");
      goto cleanup;
    }

    tmp_pattern_len = intern_pattern_len = strlen(intern_pattern);
    /* 
     * Loop over each characters of the pattern.
     * Look for escape sequences, comments, spaces etc..
     */
    for (pattern_char = 0, tmp_pattern_c = 0; pattern_char <= intern_pattern_len ; pattern_char++){
      /* 
       * NULL terminate the modified pattern when 
       * a NULL byte is encountered in intern_pattern.
       */
      if (intern_pattern[pattern_char] == '\0') {
	tmp_pattern[tmp_pattern_c] = '\0';
	break;
      }
	 
	  
    }

  }
  

 cleanup:
  if (reg_array){
    for (i = 0; i < numof_patterns; i++){
      if (reg_array[i]){
	free(reg_array[i]);
	reg_array[i] = NULL;
      }
    }
    free(reg_array);
  }
  if (intern_pattern)
    free(intern_pattern);
  
  if (tmp_pattern)
    free(tmp_pattern);
  
  return NULL;
}